<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Lou Zhou">
<meta name="author" content="Zachary Pipping">

<title>PassPredictR: Contextualizing NFL Throwing Decisions By Modeling Receiver Choice</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="PassPredictR_Report_files/libs/clipboard/clipboard.min.js"></script>
<script src="PassPredictR_Report_files/libs/quarto-html/quarto.js"></script>
<script src="PassPredictR_Report_files/libs/quarto-html/popper.min.js"></script>
<script src="PassPredictR_Report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="PassPredictR_Report_files/libs/quarto-html/anchor.min.js"></script>
<link href="PassPredictR_Report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="PassPredictR_Report_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="PassPredictR_Report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="PassPredictR_Report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="PassPredictR_Report_files/libs/bootstrap/bootstrap-c0367b04c37547644fece4185067e4a7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">PassPredictR: Contextualizing NFL Throwing Decisions By Modeling Receiver Choice</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Authors</div>
  <div class="quarto-title-meta-heading">Affiliations</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="lou-zhou.github.io">Lou Zhou</a> <a href="mailto:lz80@rice.edu" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Rice University
          </p>
      </div>
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="zachbtw.github.io">Zachary Pipping</a> <a href="mailto:zrpipping@gmail.com" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            University of Florida
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>The most important decision made by a quarterback during a throwing play in football is the throw target. In the same play, deciding to throw to one receiver may lead to a game-altering touchdown, and a throw to another receiver may result in a game-ending turnover. We can see this decision-making process in a game-tying touchdown throw from P.J. Walker to D.J. Moore against the Atlanta Falcons.</p>
<div class="text-center">
<p><img src="Assets/Slides_Assets/DJ_MOORE_TIES_THE_GAME.gif"></p>
</div>
<p>While a fantastic throw and catch, with 20 seconds left, P.J. Walker has several options, like to throw to a closer receiver and quickly get out of bounds to gain some yardage for a more manageable attempt for a touchdown. Given the available safer choices, what would we expect other quarterbacks to do in this situation? Would they play it safe and throw to the closer man, or make the same decision to throw it down the field into double coverage for a chance to tie the game, despite the risk?</p>
<p>This paper aims to explore questions like these by modeling who the expected receiver would be given a game situation. By contextualizing throwing decisions, we can determine which players deviate from our expectations the most, if this deviation leads to stronger or weaker performances, and provide better nuance to assess throwing players. For example, for particularly harmful interceptions, we can contextualize the decision by determining whether other quarterbacks would make that same decision.</p>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<p>In modeling this decision-making process, this work uses tracking and event data from the 2024 Big Data Bowl,<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> which covers players from the first 9 weeks of the 2022 NFL Season.</p>
<div class="text-center">
<p><img src="Assets/Slides_Assets/highWP.gif"></p>
</div>
<p>Within this dataset, there are four different subtypes of data:</p>
<ul>
<li><p><strong>Game Data:</strong> Data which describes information about the such as the teams playing, date and time of the game, and final scorelines.</p></li>
<li><p><strong>Play Data:</strong> Data describing the context and result of each play within each game, including the quarter, down, yards to go, pre-snap win probabilities, and formations.</p></li>
<li><p><strong>Player Play Data:</strong> Data describing statistics for each player involved in a play, such as what route was ran by the player or an indicator describing if the player was targeted for a throw.</p></li>
<li><p><strong>Tracking Data:</strong> Data describing the locations of players and the football at every frame of a play, including x, y coordinates, player orientation, movement speed, and direction.</p></li>
</ul>
<p>In this analysis, we exclusively look at throwing plays with an obvious target, removing spikes and throwaways.</p>
</section>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<p>In following approaches to similar problems in soccer,<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> we treat the problem of expected receiver as a learning-to-rank problem (LTR), building a model to generate a relative ranking for all receivers over the course of a play. This ranking approach allows us to take into account the other receivers when predicting most-likely receiver. A receiver may be wide open, but if another receiver is a much stronger option, the ranking approach will be able to take this difference into context.</p>
<p>On the other hand, a classification approach treats every recipient as an independent entry, disregarding other receivers. While this effect can be mitigated by applying a softmax normalization to the receivers of a play, we chose to pursue a ranking model to better account for other receivers when predicting who the ball is going to.</p>
<p>While this problem has been broached with a deep learning method<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, we intend to use XGBoost with dozens of hand-crafted features to derive these rankings, aiming to build a model with similar prediction power with newer tracking data and a less computationally expensive approach. This also allows us to have more interpretable results, opening our work up to a broader audiences and discussions.</p>
<section id="the-obvious-first-answer-spacing" class="level3">
<h3 class="anchored" data-anchor-id="the-obvious-first-answer-spacing">The Obvious First Answer: Spacing</h3>
<p>An obvious initial answer to finding expected receiver is simply taking the receiver that is the most open at the time of throw. While this has some predictive power, with 31.6% of throws going to the player who is furthest from their closest defender, compared to the 20% baseline (guessing out of 5 at random), this spacing at throw still tells a relatively incomplete story.</p>
<div class="text-center">
<p><img src="Assets/Slides_Assets/dadamsthrow.gif" width="600"></p>
</div>
<p>As exemplified by this throw, Davante Adams is well covered at the time of pass release, but because of speed and direction differences with his closest defender, he is able to find separation by the time the catch is made. It is often the potential to find space at time of catch that is more important than space at time of throw.</p>
<p>Therefore, to derive a proxy for space at reception, we account for the speed and direction of a player at time of throw, deriving a distance between a receiver and a defender with the speed vectors.</p>
<div class="text-center">
<p><img src="Assets/Slides_Assets/speedVect.png" width="400" style="display: inline-block; margin-right: 10px;"> <img src="Assets/Slides_Assets/corr_plot.png" width="300" style="display: inline-block;"></p>
</div>
<p>By adding speed and orientation, this distance correlates stronger with separation at catch, generating a correlation of 0.811 as compared to the correlation with current separation and catch separation, with a correlation of 0.73.</p>
</section>
<section id="a-proxy-for-qb-information-qb-vision" class="level3">
<h3 class="anchored" data-anchor-id="a-proxy-for-qb-information-qb-vision">A Proxy for QB Information: QB Vision</h3>
<p>It’s no secret that where the quarterback is looking plays a huge part in his decision making process, and therefore in predicting where he’ll be throwing. It was crucial to our model’s completeness, therefore, to develop some way to diagnose where the QB is looking in relation to the various passing options.</p>
<div class="text-center">
<p><img src="Assets/Slides_Assets/vision_example.gif" width="800"> <img src="Assets/Slides_Assets/Angle_diff_Histogram.png" height="300"></p>
</div>
</section>
<section id="final-feature-set" class="level3">
<h3 class="anchored" data-anchor-id="final-feature-set">Final Feature Set</h3>
<p>In conjunction with these two metrics, we derive a feature set which captures the game-state in three categories: the receiver, the quarterback, and the game context.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Feature Category</th>
<th>Features</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Recipient Features</strong></td>
<td>- <em>Distance (x, y, magnitude)*</em> <br> - <em>Speed Differences (x, y, magnitude)*</em> <br> - <em>Orientation Differences*</em> <br> - <em>Speed Vector Distances*</em> <br> - Receiver Position <br> - First Down Indicator <br> - Number of Defenders in 5 Yard Radius Facing Receiver Movement<br> - Angle between QB Orientation and Receiver 5 Frames Prior <br></td>
</tr>
<tr class="even">
<td><strong>Quarterback Features</strong></td>
<td>- Distance from Receiver <br> - Movement Vector <br> - Under Pressure Indicator</td>
</tr>
<tr class="odd">
<td><strong>Game Context</strong></td>
<td>- Quarter <br> - Down and Distance <br> - Score Differential <br> - Time Remaining</td>
</tr>
</tbody>
</table>
<p><br><em>*Feature taken relative to the top-3 closest defenders</em></p>
<p>Using these features, we build an XGBoost ranking model where we use a random search hyperparameter tuning approach, validated using 5-fold cross validation, with folds along games, which yields a top-1 accuracy of 59.9 <span class="math inline">\(\pm\)</span> 0.5%, significantly stronger than both a naive estimate(20%) as well as the separation based approach(31.6%). Additionally, given the inherent variability in quarterback decision-making as well as defenses looking to prioritizing preventing an obvious open receiver, this accuracy reflects strong model performance.</p>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>In applying this model, we illustrate potential use cases for our model in analyzing quarterbacks. However, for future usage, work should be done in predicting the utility of potential receivers, allowing decision analysis to be done in lieu of what the optimal throwing decision should be. We believe that this model can and should be used beyond the simple point estimates we generate here.</p>
<section id="expected-target-for-the-dj-moore-throw" class="level3">
<h3 class="anchored" data-anchor-id="expected-target-for-the-dj-moore-throw">Expected Target for the DJ Moore Throw</h3>
<p>We can then apply our model back to the DJ Moore throw to determine the expected target, given the game state:</p>
<div class="text-center">
<p><img src="Assets/Slides_Assets/PJMoorePredictions.png" width="500" style="display: inline-block; margin-right: 10px;"> <img src="Assets/Slides_Assets/moore_throw_rankings.png" width="200" style="display: inline-block;"></p>
</div>
<p>We see that the expected receiver is Stephen Sullivan, where a reception could keep the drive going and gain strong yardage, while the actual receiver, D.J. Moore is ranked the 2nd most likely receiver. Therefore, we can infer that the throw by P.J. Walker is not the expected choice and that other quarterbacks would have likely played it safer and made the throw to Sullivan.</p>
</section>
<section id="finding-the-most-predictable-and-unpredictable-quarterbacks" class="level3">
<h3 class="anchored" data-anchor-id="finding-the-most-predictable-and-unpredictable-quarterbacks">Finding the Most Predictable and Unpredictable Quarterbacks</h3>
<p>Using our model, we can also derive estimations for how predictable or unpredictable a quarterback is by finding the proportion of times they agree with the model choice.</p>
<div class="text-center">
<p><img src="Assets/Slides_Assets/MostUnPredictable.png" width="300" style="display: inline-block; margin-right: 10px;"> <img src="Assets/Slides_Assets/MostPredictable.png" width="300" style="display: inline-block;"></p>
</div>
<p>In applying the eye-test, we see that Jameis Winston, a quarterback infamous for playing in a very erratic and unpredictable manner, being the quarterback with the second lowest proportion of throws agreeing with the model. We also see Miami quarterback Tua Tagovailoa agreeing with the model the least; this disagreement could be due to the fact that Tagovailoa is the only left handed quarterback in the league, causing his decisions to be harder to model, with the rest of the league being right-handed.</p>
<p>Looking at the most predictable players, we see players like Tannehill and Ryan, who are moreso known at this stage of their careers for making safer, more conservative throws. However, we should note that this is a simple estimate as quarterbacks will inherently face different situations, so some players will not have the same opportunities to target more uncommon receivers as there might not be any other viable candidates.</p>
</section>
<section id="identifying-potential-opportunities-for-optimization" class="level3">
<h3 class="anchored" data-anchor-id="identifying-potential-opportunities-for-optimization">Identifying Potential Opportunities for Optimization</h3>
<p>By comparing YPA and completion rate for throws following the expected target and throws to other receivers, we can identify players who may benefit from throwing more conventional throws.</p>
<div class="text-center">
<p><img src="Assets/Slides_Assets/QBClustering_nt.png" width="600"></p>
</div>
<p>In this comparison, we see players like Teddy Bridgewater and Marcus Mariota, who gain significantly more yardage and are more accurate when throwing to the expected receiver, indicating that they may benefit from throwing more to the expected receiver.</p>
<p>On the other hand, players like Jameis Winston and P.J. Walker are finding more yardage with more unconventional throws, indicating that they are finding success with these atypical passes. However, since we are looking at YPA, interceptions and incompletions are essentially treated the same, so this approach may be overvaluing players who make very risky throws that are more likely to get intercepted.</p>
<p>In addition, like the predictability of our quarterbacks, the players will inherently face different situations, so certain players may not have as many opportunities to have receivers which are strong options but might not be the obvious choice.</p>
</section>
<section id="model-feature-importance" class="level3">
<h3 class="anchored" data-anchor-id="model-feature-importance">Model Feature Importance</h3>
<div class="text-center">
<p><img src="Assets/Slides_Assets/vip_plot.png" width="600"></p>
</div>
<p>In looking at feature importance, we see that the movement direction of the quarterback as well as the line of sight 5 frames prior are the most importance factor in deciding the expected receiver. Given that cross-body throws are generally discouraged, this importance of the movement direction is expected. In looking at the quarterback line of sight, this importance is also to be expected as it reflects the information the quarterback has by what he sees. If the quarterback is not actively aware of a certain receiver, he will almost never target him.</p>
</section>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<p>Given the importance of the decision to target a quarterback, we contextualize the decisions behind these throws by building a ranking model using XGBoost on hand-craft features like speed velocity difference and derivations from line of sight, generating a model accuracy of 59.9%, significantly stronger than both the naive baseline(20%) as well as throws to the most open receiver at time of throw(31.6%). Through this model, we are able to derive a number of metrics surrounding the decision-making ability of a quarterback, such as point estimates for the predictability of a quarterback as well as finding opportunities for potential improvement in decision-making.</p>
<section id="limitations-and-future-work" class="level3">
<h3 class="anchored" data-anchor-id="limitations-and-future-work">Limitations and Future Work</h3>
<p>There are still a strong number of opportunities to add more features and refine the model. For example, it may be worth looking into receiver skill as a decision, as quarterbacks are more likely to throw to their number one receiver. We also only use a binary estimate for pressure, while future work should expand and add nuance to what the pressure actually looked like. Likewise, future work should consider pre-snap factors like coverage mismatches to update target probabilities during a throw. Additionally, the usage of proxies for both future separation and quarterback line of sight as well as the relatively can add bias into the model which could affect model results.</p>
<p>In our applications of the model with our derivations of predictability and quarterback optimization, the differences in situations that quarterbacks will face will inherently add bias to these point estimates, so future work should account for the quality of the other decisions.</p>
<p>We believe that this model can be used with other factors to generate stronger estimates of quarterback decision-making ability. For example, if a quarterback was constantly making the optimal play in terms of expected yardage but these targets are not the expected target, like a similar approach in soccer<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>, we can generate a proxy for this quarterback’s ability to find strong, hard to find throws.</p>
</section>
</section>
<section id="acknowledgements" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgements">Acknowledgements</h2>
<p>We would like to thank Quang Nguyen, Dr.&nbsp;Ron Yurko, and our outside sponsor, Dr.&nbsp;Karim Kassam and Teamworks for their guidance and input for this work. In addition, thank you to the Carnegie Mellon Statistics Department for providing the opportunity and resources to conduct research throughout the summer.</p>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Michael Lopez, Thompson Bliss, Ally Blake, Andrew Patton, Jonathan McWilliams, Addison Howard, and Will Cukierski. NFL Big Data Bowl 2024. https://kaggle.com/competitions/nfl-big-data-bowl-2024, 2023. Kaggle.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Li, Heng &amp; Zhang, Zhiying. (2019). Predicting the Receivers of Football Passes. 10.1007/978-3-030-17274-9_15.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Burke, Brian. “DeepQB: Deep Learning with Player Tracking to Quantify Quarterback Decision-Making &amp; Performance.” MIT Sloan Sports Analytics Conference, 1 Mar.&nbsp;2019.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Pieter Robberechts, Maaike Van Roy, and Jesse Davis. 2023. Un-xPass: Measuring Soccer Player’s Creativity. In Proceedings of the 29th ACM SIGKDD Conference on Knowledge Discovery and Data Mining (KDD ’23). Association for Computing Machinery, New York, NY, USA, 4768–4777. https://doi.org/10.1145/3580305.3599924<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>